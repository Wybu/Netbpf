clang -cc1 -triple x86_64-unknown-linux-gnu -emit-llvm-bc -emit-llvm-uselists -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name main.c -mrelocation-model pic -pic-level 2 -pic-is-pie -fno-jump-tables -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=4 -debugger-tuning=gdb -fdebug-compilation-dir=/usr/src/linux-headers-6.14.0-35-generic -fcoverage-compilation-dir=/usr/src/linux-headers-6.14.0-35-generic -nostdsysteminc -nobuiltininc -resource-dir lib/clang/18 -isystem /virtual/lib/clang/include -include ./include/linux/kconfig.h -include /virtual/include/bcc/bpf.h -include /virtual/include/bcc/bpf_workaround.h -include /virtual/include/bcc/helpers.h -isystem /virtual/include -I /home/quyna/Desktop/DATN_Quy -D __BPF_TRACING__ -I arch/x86/include/ -I arch/x86/include/generated -I include -I arch/x86/include/uapi -I arch/x86/include/generated/uapi -I include/uapi -I include/generated/uapi -D __KERNEL__ -D KBUILD_MODNAME="bcc" -O2 -Wno-deprecated-declarations -Wno-gnu-variable-sized-type-not-at-end -Wno-pragma-once-outside-header -Wno-address-of-packed-member -Wno-unknown-warning-option -Wno-unused-value -Wno-pointer-sign -Wno-macro-redefined -ferror-limit 19 -fcf-protection=full -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -vectorize-loops -vectorize-slp -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o main.bc -x c /virtual/main.c
In file included from /virtual/main.c:15:
In file included from include/uapi/linux/ptrace.h:183:
In file included from arch/x86/include/asm/ptrace.h:175:
In file included from arch/x86/include/asm/paravirt_types.h:12:
In file included from arch/x86/include/asm/nospec-branch.h:15:
arch/x86/include/asm/current.h:47:10: warning: multiple identical address spaces specified for type [-Wduplicate-decl-specifier]
   47 |                 return this_cpu_read_const(const_pcpu_hot.current_task);
      |                        ^
arch/x86/include/asm/percpu.h:578:36: note: expanded from macro 'this_cpu_read_const'
  578 | #define this_cpu_read_const(pcp)                        __raw_cpu_read_const(pcp)
      |                                                         ^
arch/x86/include/asm/percpu.h:163:35: note: expanded from macro '__raw_cpu_read_const'
  163 | #define __raw_cpu_read_const(pcp)       __raw_cpu_read(, , pcp)
      |                                         ^
arch/x86/include/asm/percpu.h:155:30: note: expanded from macro '__raw_cpu_read'
  155 |         *(qual __my_cpu_type(pcp) *)__my_cpu_ptr(&(pcp));               \
      |                                     ^
note: (skipping 1 expansions in backtrace; use -fmacro-backtrace-limit=0 to see all)
arch/x86/include/asm/percpu.h:94:40: note: expanded from macro '__my_cpu_type'
   94 | #define __my_cpu_type(var)      typeof(var) __percpu_seg_override
      |                                             ^
arch/x86/include/asm/percpu.h:45:32: note: expanded from macro '__percpu_seg_override'
   45 | # define __percpu_seg_override  __seg_gs
      |                                 ^
<built-in>:358:33: note: expanded from macro '__seg_gs'
  358 | #define __seg_gs __attribute__((address_space(256)))
      |                                 ^
In file included from /virtual/main.c:15:
In file included from include/uapi/linux/ptrace.h:183:
In file included from arch/x86/include/asm/ptrace.h:175:
In file included from arch/x86/include/asm/paravirt_types.h:12:
In file included from arch/x86/include/asm/nospec-branch.h:15:
arch/x86/include/asm/current.h:47:10: warning: multiple identical address spaces specified for type [-Wduplicate-decl-specifier]
arch/x86/include/asm/percpu.h:578:36: note: expanded from macro 'this_cpu_read_const'
  578 | #define this_cpu_read_const(pcp)                        __raw_cpu_read_const(pcp)
      |                                                         ^
arch/x86/include/asm/percpu.h:163:35: note: expanded from macro '__raw_cpu_read_const'
  163 | #define __raw_cpu_read_const(pcp)       __raw_cpu_read(, , pcp)
      |                                         ^
arch/x86/include/asm/percpu.h:155:9: note: expanded from macro '__raw_cpu_read'
  155 |         *(qual __my_cpu_type(pcp) *)__my_cpu_ptr(&(pcp));               \
      |                ^
arch/x86/include/asm/percpu.h:94:40: note: expanded from macro '__my_cpu_type'
   94 | #define __my_cpu_type(var)      typeof(var) __percpu_seg_override
      |                                             ^
arch/x86/include/asm/percpu.h:45:32: note: expanded from macro '__percpu_seg_override'
   45 | # define __percpu_seg_override  __seg_gs
      |                                 ^
<built-in>:358:33: note: expanded from macro '__seg_gs'
  358 | #define __seg_gs __attribute__((address_space(256)))
      |                                 ^
#if defined(BPF_LICENSE)
#error BPF_LICENSE cannot be specified through cflags
#endif
#if !defined(CONFIG_CC_STACKPROTECTOR)
#if defined(CONFIG_CC_STACKPROTECTOR_AUTO) \
    || defined(CONFIG_CC_STACKPROTECTOR_REGULAR) \
    || defined(CONFIG_CC_STACKPROTECTOR_STRONG)
#define CONFIG_CC_STACKPROTECTOR
#endif
#endif
/*  DISCLAIMER
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE. */

// SPDX-License-Identifier: GPL-2.0+
#define BPF_LICENSE GPL

#include "bpf.h"
#include <uapi/asm/fcntl.h>
#include <uapi/linux/ptrace.h>

#ifndef true
#define true 1
#endif
#ifndef false
#define false 0
#endif

// config data from userspace
BPF_ARRAY(config, config_t, 1);

// event patterns from userspace
BPF_ARRAY(patterns, event_pattern_t, MAX_PATTERNS);

// hash map (pid -> pidstat) to analyze file access pattern per pid and flag suspicious pid
BPF_HASH(pidstats, u32 /* pid */, pidstat_t, 1024);

#if defined(BPF_RINGBUF_OUTPUT)
#define EVENTS_RINGBUF 1
// ring buffer to report events (16 pages x 4096 bytes shared across all CPUs)
// getconf PAGESIZE returns the page size in bytes (4096)
BPF_RINGBUF_OUTPUT(events, 1 << 4);
#else
#define EVENTS_RINGBUF 0
BPF_PERF_OUTPUT(events);
#endif


// get config from BPF_ARRAY
__attribute__((always_inline))
static __always_inline config_t *get_config() {
    int zero = 0;
    return bpf_map_lookup_elem((void *)bpf_pseudo_fd(1, -1), &zero);
}

// get pid stats from BPF_HASH
__attribute__((always_inline))
static __always_inline pidstat_t *get_stats(u32 *pid) {
    pidstat_t zero;
    __builtin_memset(&zero, 0, sizeof(zero));
    zero.event_bitmap = BITMAP_INIT;
    zero.last_reset_ts = bpf_ktime_get_ns();
    return ({typeof(pidstats.leaf) *leaf = bpf_map_lookup_elem_(bpf_pseudo_fd(1, -3), pid); if (!leaf) { bpf_map_update_elem_(bpf_pseudo_fd(1, -3), pid, &zero, BPF_NOEXIST); leaf = bpf_map_lookup_elem_(bpf_pseudo_fd(1, -3), pid);}leaf;});
}

// update pid stats (but does not save)
__attribute__((always_inline))
static __always_inline void update_stats(config_t *conf, event_type_t type, const pidstat_t *curr, pidstat_t *updated) {
   __builtin_memcpy(updated, curr, sizeof(*updated));

    time_t now = bpf_ktime_get_ns();
    time_t time_since_reset = now - curr->last_reset_ts;
    if (conf && curr->last_reset_ts && (time_since_reset > conf->reset_period_ns)) {
        // reset counters
        __builtin_memset(updated->event_counts, 0, sizeof(counts_t) * EVENT_TYPES);
        updated->last_reset_ts = now;
    }
    // this doesnt work: updated->event_counts[type]++; - maybe try with bpf_probe_kernel_read?
    switch (type) {
        case T_OPEN:
            updated->event_counts[0]++;
            break;
        case T_CREATE:
            updated->event_counts[1]++;
            break;
        case T_DELETE:
            updated->event_counts[2]++;
            break;
        case T_ENCRYPT:
            updated->event_counts[3]++;
            break;
        case T_READ:
            updated->event_counts[4]++;
            break;
        case T_WRITE:
            updated->event_counts[5]++;
            break;
        case T_SCAN:
            updated->event_counts[6]++;
            break;
        case T_RENAME:
            updated->event_counts[7]++;
            break;
        case T_NET_SOCKET:
            updated->event_counts[8]++;
            break;
        case T_NET_CONNECT:
            updated->event_counts[9]++;
            break;
        default:
            break;
    }
    // shift and add the event_type
    updated->event_bitmap = (curr->event_bitmap << BITS_PER_EVENT) | (bitmap_t)type;
}

// analyse pid stats and compute flags
__attribute__((always_inline))
static __always_inline void analyze_stats(config_t *conf, pidstat_t* stats, event_flags_t *flags) {
    __builtin_memset(flags, 0, sizeof(event_flags_t));

    // check counters
    // TODO: consider counts per unit of time & reset counts after some delay    
    for (u8 i=0; i < EVENT_TYPES; i++) {
        if (conf && stats->event_counts[i] > conf->thresholds[i]) {
            // set the i-th bit to 1
            flags->thresholds_crossed |= (1 << i); 
            flags->severity = S_MINOR;
        }
    }

    // check pattern matches
    for (u8 i=0; i < MAX_PATTERNS; i++) {
        int k = i;
        event_pattern_t *pat = bpf_map_lookup_elem((void *)bpf_pseudo_fd(1, -2), &k);
        if (pat && pat->bitmask) {
            // 0xABCDE012 & 0x00000FFF == 0x00000012
            if ((stats->event_bitmap & pat->bitmask) == pat->bitmap) {
                flags->pattern_id = i + 1;
                flags->severity = S_MAJOR;
                stats->pattern_counts++;
                // reset the bitmap
                stats->event_bitmap = BITMAP_INIT;
                break;
            }
        }
    }
}

// submit event for userspace via ring buffer
__attribute__((always_inline))
static __always_inline int submit_event(void *ctx, u32 pid, event_type_t type, event_flags_t flags, const char *filename) {
#if EVENTS_RINGBUF
    event_t *event = bpf_ringbuf_reserve((void *)bpf_pseudo_fd(1, -4), sizeof(event_t), 0);
    if (!event) {
        return 1;
    }
#else
    event_t local = {};
    event_t *event = &local;
#endif
    event->ts = bpf_ktime_get_ns();
    event->pid = pid;
    event->type = type;
    event->flags = flags;

    bpf_get_current_comm(&event->comm, TASK_COMM_LEN);

    if (filename) {
        int ret = bpf_probe_read_user_str(event->filename, FILENAME_SIZE, filename);
        if (ret < 0) {
            bpf_probe_read_kernel_str(event->filename, FILENAME_SIZE, filename);
        }
    } else {
        event->filename[0] = '\0';
    }

#if EVENTS_RINGBUF
    bpf_ringbuf_submit(event, 0);
#else
    events.perf_submit(ctx, event, sizeof(*event));
#endif
    return 0;
}

// update stats, analyse and submit event
__attribute__((always_inline))
static __always_inline int update_and_submit(void *ctx, event_type_t type, const char* filename, int emit_always) {
    u32 pid = bpf_get_current_pid_tgid();

    // get config
    config_t *conf = get_config();

    // get stats from BPF_HASH
    pidstat_t *curr = get_stats(&pid);
    if (!curr) {
        // cleanup old pid entries in pidstats?
        return 0;
    }

    // update stats
    pidstat_t updated;
    update_stats(conf, type, curr, &updated);

    // analyse stats
    event_flags_t flags;
    analyze_stats(conf, &updated, &flags);

   // save stats in BPF_HASH
    bpf_map_update_elem((void *)bpf_pseudo_fd(1, -3), &pid, &updated, BPF_ANY);

    // Emit logic:
    // - Submit ALL events to userspace (for log_all.csv)
    // - But emit_always flag controls whether they go to log.csv (original logic)
    // - If emit_always = 1: submit (will be in log.csv if severity >= min_severity)
    // - If emit_always = 0: submit (will be in log.csv only if pattern matched)
    //   All events go to log_all.csv, but only filtered events go to log.csv
    return submit_event(ctx, pid, type, flags, filename);
}

// sys_open and sys_openat both have args->filename
struct tracepoint__syscalls__sys_enter_open {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	const char * filename;
	s64 flags;
	umode_t mode;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_open")))
TRACEPOINT_PROBE(syscalls, sys_enter_open) {

    // args from /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format
    event_type_t type = T_OPEN;
    if (args->flags & O_CREAT) {
        type = T_CREATE;
    }
    return update_and_submit(args, type, args->filename, true);
}

// sys_open and sys_openat both have args->filename
struct tracepoint__syscalls__sys_enter_openat {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	s64 dfd;
	const char * filename;
	s64 flags;
	umode_t mode;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_openat")))
TRACEPOINT_PROBE(syscalls, sys_enter_openat) {

    // args from /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format
    event_type_t type = T_OPEN;
    if (args->flags & O_CREAT) {
        type = T_CREATE;
    }
    return update_and_submit(args, type, args->filename, true);
}

// sys_unlink and sys_unlinkat both have args->pathname
struct tracepoint__syscalls__sys_enter_unlink {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	const char * pathname;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_unlink")))
TRACEPOINT_PROBE(syscalls, sys_enter_unlink) {

    // args from /sys/kernel/debug/tracing/events/syscalls/sys_enter_unlink/format
    return update_and_submit(args, T_DELETE, args->pathname, true);
}

// sys_unlink and sys_unlinkat both have args->pathname
struct tracepoint__syscalls__sys_enter_unlinkat {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	s64 dfd;
	const char * pathname;
	s64 flag;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_unlinkat")))
TRACEPOINT_PROBE(syscalls, sys_enter_unlinkat) {

    // args from /sys/kernel/debug/tracing/events/syscalls/sys_enter_unlink/format
    return update_and_submit(args, T_DELETE, args->pathname, true);
}

// uprobe on openssl
// int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
//                        ENGINE *impl, const unsigned char *key, const unsigned char *iv);
// int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
//                       ENGINE *impl, const unsigned char *key, const unsigned char *iv, int enc);
__attribute__((section(".bpf.fn.trace_encrypt1")))
int trace_encrypt1(struct pt_regs *ctx) {

    const char func[FILENAME_SIZE] = "EVP_EncryptInit_ex";
    return update_and_submit(ctx, T_ENCRYPT, func, true);
}
// int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
//                  unsigned char **ek, int *ekl, unsigned char *iv,
//                  EVP_PKEY **pubk, int npubk);
__attribute__((section(".bpf.fn.trace_encrypt2")))
int trace_encrypt2(struct pt_regs *ctx) {

    const char func[FILENAME_SIZE] = "EVP_SealInit";
    return update_and_submit(ctx, T_ENCRYPT, func, true);
}

struct tracepoint__syscalls__sys_enter_read {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	u64 fd;
	char * buf;
	size_t count;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_read")))
TRACEPOINT_PROBE(syscalls, sys_enter_read) {

    const char func[FILENAME_SIZE] = "sys_read";
    return update_and_submit(args, T_READ, func, false);
}

struct tracepoint__syscalls__sys_enter_write {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	u64 fd;
	const char * buf;
	size_t count;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_write")))
TRACEPOINT_PROBE(syscalls, sys_enter_write) {

    const char func[FILENAME_SIZE] = "sys_write";
    return update_and_submit(args, T_WRITE, func, false);
}

struct tracepoint__syscalls__sys_enter_getdents64 {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	u64 fd;
	struct linux_dirent64 * dirent;
	u64 count;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_getdents64")))
TRACEPOINT_PROBE(syscalls, sys_enter_getdents64) {

    const char func[FILENAME_SIZE] = "sys_getdents64";
    return update_and_submit(args, T_SCAN, func, false);
}

struct tracepoint__syscalls__sys_enter_rename {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	const char * oldname;
	const char * newname;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_rename")))
TRACEPOINT_PROBE(syscalls, sys_enter_rename) {

    return update_and_submit(args, T_RENAME, args->newname, true);
}

struct tracepoint__syscalls__sys_enter_renameat {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	s64 olddfd;
	const char * oldname;
	s64 newdfd;
	const char * newname;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_renameat")))
TRACEPOINT_PROBE(syscalls, sys_enter_renameat) {

    return update_and_submit(args, T_RENAME, args->newname, true);
}

struct tracepoint__syscalls__sys_enter_renameat2 {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	s64 olddfd;
	const char * oldname;
	s64 newdfd;
	const char * newname;
	u64 flags;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_renameat2")))
TRACEPOINT_PROBE(syscalls, sys_enter_renameat2) {

    return update_and_submit(args, T_RENAME, args->newname, true);
}

struct tracepoint__syscalls__sys_enter_socket {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	s64 family;
	s64 type;
	s64 protocol;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_socket")))
TRACEPOINT_PROBE(syscalls, sys_enter_socket) {

    const char func[FILENAME_SIZE] = "sys_socket";
    return update_and_submit(args, T_NET_SOCKET, func, false);
}

struct tracepoint__syscalls__sys_enter_connect {
	u64 __do_not_use__;
	int __syscall_nr;
	char __pad_12;
	char __pad_13;
	char __pad_14;
	char __pad_15;
	s64 fd;
	struct sockaddr * uservaddr;
	s64 addrlen;
};
__attribute__((section(".bpf.fn.tracepoint__syscalls__sys_enter_connect")))
TRACEPOINT_PROBE(syscalls, sys_enter_connect) {

    const char func[FILENAME_SIZE] = "sys_connect";
    return update_and_submit(args, T_NET_CONNECT, func, false);
}

#include <bcc/footer.h>
2 warnings generated.
